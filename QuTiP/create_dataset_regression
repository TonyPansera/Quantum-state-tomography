#!/usr/bin/env python3
"""
Dataset generator for 1-qubit quantum state tomography (regression).
- Uses QuTiP to construct qubit states and Pauli operators.
- Generates random pure states uniformly on the Bloch sphere.
- Simulates finite-shot measurements in X, Y, Z.
- Outputs a CSV file with:
    features:  X_mean, Y_mean, Z_mean
    targets:   theta, phi, cos_phi, sin_phi
    (plus ideal expectation values for reference)
"""

import numpy as np
import pandas as pd
from qutip import basis, sigmax, sigmay, sigmaz, expect

# ----------------------------
# Global parameters
# ----------------------------

N_STATES = 5000        # number of different states on the Bloch sphere
N_SHOTS = 200          # number of measurement shots per observable (X,Y,Z)
RANDOM_SEED = 42       # for reproducibility
OUTPUT_CSV = "../data/qst_regression_dataset.csv"


# ----------------------------
# State generation
# ----------------------------

def sample_bloch_angles():
    """
    Sample (theta, phi) uniformly on the Bloch sphere.

    Sampling rule:
        u ~ Uniform[-1,1]
        theta = arccos(u)
        phi ~ Uniform[0, 2π)
    """
    u = np.random.uniform(-1.0, 1.0)
    theta = np.arccos(u)
    phi = np.random.uniform(0.0, 2.0 * np.pi)
    return theta, phi


def ket_from_angles(theta, phi):
    """
    Construct a 1-qubit pure state |psi(theta, phi)> in computational basis:

        |psi> = cos(theta/2) |0> + e^{i phi} sin(theta/2) |1>
    """
    c0 = np.cos(theta / 2.0)
    c1 = np.sin(theta / 2.0) * np.exp(1j * phi)
    # |0> and |1> in computational basis
    zero = basis(2, 0)
    one = basis(2, 1)
    ket = c0 * zero + c1 * one
    return ket.unit()


# ----------------------------
# Measurement simulation
# ----------------------------

# Pauli operators
SIGMA_X = sigmax()
SIGMA_Y = sigmay()
SIGMA_Z = sigmaz()


def simulate_pauli_measurements(ket, n_shots):
    """
    Simulate finite-shot projective measurements in the Pauli bases X, Y, Z.

    For each observable O ∈ {X, Y, Z}:
        - Compute ideal expectation value <O> = Tr(ρ O)
        - Use Bernoulli sampling with:
              P(+1) = (1 + <O>) / 2
              P(-1) = (1 - <O>) / 2
        - Estimate empirical mean over n_shots.

    Returns:
        (
          X_mean, Y_mean, Z_mean,
          X_ideal, Y_ideal, Z_ideal
        )
    """
    rho = ket * ket.dag()  # density matrix (not strictly needed for 1 qubit but clean)

    # Ideal expectation values
    ex_x = float(expect(SIGMA_X, rho))
    ex_y = float(expect(SIGMA_Y, rho))
    ex_z = float(expect(SIGMA_Z, rho))

    # Helper: sample ±1 outcomes for one observable
    def sample_mean_from_expectation(exp_val, shots):
        p_plus = (1.0 + exp_val) / 2.0
        # Draw shots in {+1, -1}
        outcomes = np.where(
            np.random.rand(shots) < p_plus,
            1.0,
            -1.0,
        )
        return outcomes.mean()

    # Empirical means from finite shots
    x_mean = sample_mean_from_expectation(ex_x, n_shots)
    y_mean = sample_mean_from_expectation(ex_y, n_shots)
    z_mean = sample_mean_from_expectation(ex_z, n_shots)

    return x_mean, y_mean, z_mean, ex_x, ex_y, ex_z


# ----------------------------
# Dataset generation
# ----------------------------

def generate_dataset(n_states, n_shots):
    """
    Generate a dataset for regression-based quantum state tomography of 1 qubit.

    For each state k:
        - Sample (theta_k, phi_k) uniformly on the Bloch sphere.
        - Build |psi_k>.
        - Simulate measurements in X, Y, Z with n_shots.
        - Store:
            features:  X_mean, Y_mean, Z_mean
            targets:   theta, phi, cos_phi, sin_phi
            extras:    X_ideal, Y_ideal, Z_ideal
    """
    rows = []

    for k in range(n_states):
        theta, phi = sample_bloch_angles()
        ket = ket_from_angles(theta, phi)

        (x_mean, y_mean, z_mean,
         x_ideal, y_ideal, z_ideal) = simulate_pauli_measurements(ket, n_shots)

        row = {
            "X_mean": x_mean,
            "Y_mean": y_mean,
            "Z_mean": z_mean,
            "theta": theta,
            "phi": phi,
            "cos_phi": np.cos(phi),
            "sin_phi": np.sin(phi),
            "X_ideal": x_ideal,
            "Y_ideal": y_ideal,
            "Z_ideal": z_ideal,
        }
        rows.append(row)

    df = pd.DataFrame(rows)
    return df


# ----------------------------
# Main entry point
# ----------------------------


np.random.seed(RANDOM_SEED)

print("Generating dataset for 1-qubit QST regression:")
print(f"  - Number of states : {N_STATES}")
print(f"  - Shots per Pauli  : {N_SHOTS}")

df = generate_dataset(N_STATES, N_SHOTS)

print("\nSample of generated data:")
print(df.head())

df.to_csv(OUTPUT_CSV, index=False)
print(f"\nDataset saved to: {OUTPUT_CSV}")

